\section{Référence du fichier dijkstra\+\_\+malloc.\+c}
\label{dijkstra__malloc_8c}\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdbool.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$math.\+h$>$}\\*
{\ttfamily \#include $<$S\+D\+L/\+S\+D\+L.\+h$>$}\\*
{\ttfamily \#include $<$S\+D\+L/\+S\+D\+L\+\_\+ttf.\+h$>$}\\*
{\ttfamily \#include \char`\"{}dijkstra\+\_\+malloc.\+h\char`\"{}}\\*
Graphe des dépendances par inclusion de dijkstra\+\_\+malloc.\+c\+:
% FIG 0
\subsection*{Fonctions}
\begin{DoxyCompactItemize}
\item 
void {\bf clean} (char {\bf chaine}[$\,$])
\item 
void {\bf enleve\+\_\+n} (char {\bf chaine}[$\,$])
\item 
void {\bf initialise} ({\bf noeud} $\ast$tab\+\_\+noeuds, {\bf arc} $\ast$tab\+\_\+arcs)
\item 
int {\bf minimum} ({\bf noeud} $\ast$tab\+\_\+noeuds)
\item 
void {\bf trouve\+\_\+voisin} (char nom\+\_\+ville[$\,$], {\bf voisin} $\ast$tab\+\_\+voisins, {\bf arc} $\ast$tab\+\_\+arcs)
\item 
int {\bf trouve\+\_\+poids\+\_\+arc} (char $\ast${\bf voisin}, char nom\+\_\+ville[$\,$], {\bf arc} $\ast$tab\+\_\+arcs)
\item 
void {\bf parcours} ({\bf noeud} $\ast$tab\+\_\+noeuds, {\bf arc} $\ast$tab\+\_\+arcs, {\bf antecedent} $\ast$tab\+\_\+antecedents, {\bf voisin} $\ast$tab\+\_\+voisins)
\item 
void {\bf pause} ()
\item 
void {\bf disque} (int cx, int cy, int rayon, int coul, S\+D\+L\+\_\+\+Surface $\ast$const {\bf ecran})
\item 
void {\bf init\+Couleurs} ()
\item 
void {\bf ligne\+Horizontale} (int x, int y, int w, Uint32 coul, S\+D\+L\+\_\+\+Surface $\ast$const {\bf ecran})
\item 
void {\bf ligne\+Verticale} (int x, int y, int h, Uint32 coul, S\+D\+L\+\_\+\+Surface $\ast$const {\bf ecran})
\item 
void {\bf echanger\+Entiers} (int $\ast$x, int $\ast$y)
\item 
void {\bf set\+Pixel} (int x, int y, Uint32 coul)
\item 
void {\bf set\+Pixel\+Verif} (int x, int y, Uint32 coul)
\item 
void {\bf ligne} (int x1, int y1, int x2, int y2, Uint32 coul)
\item 
void {\bf int\+\_\+to\+\_\+char} (int nb)
\item 
int {\bf main} ()
\end{DoxyCompactItemize}


\subsection{Documentation des fonctions}
\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!clean@{clean}}
\index{clean@{clean}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{clean(char chaine[])}]{\setlength{\rightskip}{0pt plus 5cm}void clean (
\begin{DoxyParamCaption}
\item[{char}]{chaine[$\,$]}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_a9040c7c2374a430d0447e811d7df7014}


Référencé par initialise(), int\+\_\+to\+\_\+char(), et main().

\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!disque@{disque}}
\index{disque@{disque}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{disque(int cx, int cy, int rayon, int coul, S\+D\+L\+\_\+\+Surface $\ast$const ecran)}]{\setlength{\rightskip}{0pt plus 5cm}void disque (
\begin{DoxyParamCaption}
\item[{int}]{cx, }
\item[{int}]{cy, }
\item[{int}]{rayon, }
\item[{int}]{coul, }
\item[{S\+D\+L\+\_\+\+Surface $\ast$const}]{ecran}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_a9a9d369ceb59bdbbc21a7a7d4e80ac52}
fonction creer un cercle 

Références ligne\+Horizontale().



Référencé par main(), et parcours().



Voici le graphe d\textquotesingle{}appel pour cette fonction \+:
% FIG 1


\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!echanger\+Entiers@{echanger\+Entiers}}
\index{echanger\+Entiers@{echanger\+Entiers}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{echanger\+Entiers(int $\ast$x, int $\ast$y)}]{\setlength{\rightskip}{0pt plus 5cm}void echanger\+Entiers (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{x, }
\item[{int $\ast$}]{y}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_afa26708d2c8eb3e7a5e6f904a6855e7f}


Référencé par ligne().

\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!enleve\+\_\+n@{enleve\+\_\+n}}
\index{enleve\+\_\+n@{enleve\+\_\+n}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{enleve\+\_\+n(char chaine[])}]{\setlength{\rightskip}{0pt plus 5cm}void enleve\+\_\+n (
\begin{DoxyParamCaption}
\item[{char}]{chaine[$\,$]}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_ac02c211fe4e07a031cc1040be9e2f643}


Référencé par initialise().

\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!init\+Couleurs@{init\+Couleurs}}
\index{init\+Couleurs@{init\+Couleurs}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{init\+Couleurs()}]{\setlength{\rightskip}{0pt plus 5cm}void init\+Couleurs (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_a7c8fd494e781fe53609b3843ed2aca43}
permet de changer les couleurs des cercles et segments 

Références C\+\_\+\+B\+L\+A\+NC, C\+\_\+\+B\+L\+EU, C\+\_\+\+B\+L\+E\+U\+\_\+\+F\+O\+N\+CE, C\+\_\+\+C\+Y\+AN, C\+\_\+\+C\+Y\+A\+N\+\_\+\+F\+O\+N\+CE, C\+\_\+\+G\+R\+IS, C\+\_\+\+G\+R\+I\+S\+\_\+\+C\+L\+A\+IR, C\+\_\+\+J\+A\+U\+NE, C\+\_\+\+M\+A\+G\+E\+N\+TA, C\+\_\+\+M\+A\+G\+E\+N\+T\+A\+\_\+\+F\+O\+N\+CE, C\+\_\+\+N\+O\+IR, C\+\_\+\+O\+C\+RE, C\+\_\+\+R\+O\+U\+GE, C\+\_\+\+R\+O\+U\+G\+E\+\_\+\+F\+O\+N\+CE, C\+\_\+\+V\+E\+RT, C\+\_\+\+V\+E\+R\+T\+\_\+\+F\+O\+N\+CE, couleurs, et ecran.



Référencé par main().

\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!initialise@{initialise}}
\index{initialise@{initialise}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{initialise(noeud $\ast$tab\+\_\+noeuds, arc $\ast$tab\+\_\+arcs)}]{\setlength{\rightskip}{0pt plus 5cm}void initialise (
\begin{DoxyParamCaption}
\item[{{\bf noeud} $\ast$}]{tab\+\_\+noeuds, }
\item[{{\bf arc} $\ast$}]{tab\+\_\+arcs}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_a09509d46f80b4957658574bb781c9b82}
fonction d\textquotesingle{}initialisation des variables 

Références chaine, clean(), enleve\+\_\+n(), nb\+\_\+arcs, nb\+\_\+noeuds, noeud\+::parcouru, noeud\+::poids, arc\+::poids, et ville\+\_\+arriver.



Référencé par main().



Voici le graphe d\textquotesingle{}appel pour cette fonction \+:
% FIG 2


\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!int\+\_\+to\+\_\+char@{int\+\_\+to\+\_\+char}}
\index{int\+\_\+to\+\_\+char@{int\+\_\+to\+\_\+char}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{int\+\_\+to\+\_\+char(int nb)}]{\setlength{\rightskip}{0pt plus 5cm}void int\+\_\+to\+\_\+char (
\begin{DoxyParamCaption}
\item[{int}]{nb}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_a858c73d4b9686b4496452e18c504c0c4}


Références chaine, et clean().



Référencé par main().



Voici le graphe d\textquotesingle{}appel pour cette fonction \+:
% FIG 3


\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!ligne@{ligne}}
\index{ligne@{ligne}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{ligne(int x1, int y1, int x2, int y2, Uint32 coul)}]{\setlength{\rightskip}{0pt plus 5cm}void ligne (
\begin{DoxyParamCaption}
\item[{int}]{x1, }
\item[{int}]{y1, }
\item[{int}]{x2, }
\item[{int}]{y2, }
\item[{Uint32}]{coul}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_a66f4e4eefb46bac943501dcebeb9b82a}


Références echanger\+Entiers(), et set\+Pixel\+Verif().



Référencé par main().



Voici le graphe d\textquotesingle{}appel pour cette fonction \+:
% FIG 4


\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!ligne\+Horizontale@{ligne\+Horizontale}}
\index{ligne\+Horizontale@{ligne\+Horizontale}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{ligne\+Horizontale(int x, int y, int w, Uint32 coul, S\+D\+L\+\_\+\+Surface $\ast$const ecran)}]{\setlength{\rightskip}{0pt plus 5cm}void ligne\+Horizontale (
\begin{DoxyParamCaption}
\item[{int}]{x, }
\item[{int}]{y, }
\item[{int}]{w, }
\item[{Uint32}]{coul, }
\item[{S\+D\+L\+\_\+\+Surface $\ast$const}]{ecran}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_ad4f2f130abc573c87f5a660ca949b6dd}


Référencé par disque().

\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!ligne\+Verticale@{ligne\+Verticale}}
\index{ligne\+Verticale@{ligne\+Verticale}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{ligne\+Verticale(int x, int y, int h, Uint32 coul, S\+D\+L\+\_\+\+Surface $\ast$const ecran)}]{\setlength{\rightskip}{0pt plus 5cm}void ligne\+Verticale (
\begin{DoxyParamCaption}
\item[{int}]{x, }
\item[{int}]{y, }
\item[{int}]{h, }
\item[{Uint32}]{coul, }
\item[{S\+D\+L\+\_\+\+Surface $\ast$const}]{ecran}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_aeaf6d72e43f65de2cb91a3e0eb576d0d}
\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!main@{main}}
\index{main@{main}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{main()}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_ae66f6b31b5ad750f1fe042a706a4e3d4}


Références C\+\_\+\+J\+A\+U\+NE, chaine, clean(), couleurs, disque(), ecran, init\+Couleurs(), initialise(), int\+\_\+to\+\_\+char(), ligne(), nb\+\_\+arcs, nb\+\_\+noeuds, antecedent\+::nom\+\_\+antecedent, antecedent\+::nom\+\_\+noeud, noeud\+::nom\+\_\+ville, parcours(), et pause().



Voici le graphe d\textquotesingle{}appel pour cette fonction \+:
% FIG 5


\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!minimum@{minimum}}
\index{minimum@{minimum}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{minimum(noeud $\ast$tab\+\_\+noeuds)}]{\setlength{\rightskip}{0pt plus 5cm}int minimum (
\begin{DoxyParamCaption}
\item[{{\bf noeud} $\ast$}]{tab\+\_\+noeuds}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_ae3b87a086b575787e74378732b4d4a64}
fonction qui va chercher le minimum des poids de chaque noeud pour que l\textquotesingle{}on part du noeud le plus petit, elle retourne l\textquotesingle{}undice du plus petit 

Références nb\+\_\+noeuds.



Référencé par parcours().

\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!parcours@{parcours}}
\index{parcours@{parcours}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{parcours(noeud $\ast$tab\+\_\+noeuds, arc $\ast$tab\+\_\+arcs, antecedent $\ast$tab\+\_\+antecedents, voisin $\ast$tab\+\_\+voisins)}]{\setlength{\rightskip}{0pt plus 5cm}void parcours (
\begin{DoxyParamCaption}
\item[{{\bf noeud} $\ast$}]{tab\+\_\+noeuds, }
\item[{{\bf arc} $\ast$}]{tab\+\_\+arcs, }
\item[{{\bf antecedent} $\ast$}]{tab\+\_\+antecedents, }
\item[{{\bf voisin} $\ast$}]{tab\+\_\+voisins}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_af3b22d1cb008ffeeffaff57f298814a8}
fonction principale qui appelle toutes les autres fonctions 

Références disque(), ecran, minimum(), nb\+\_\+noeuds, antecedent\+::nom\+\_\+antecedent, antecedent\+::nom\+\_\+noeud, noeud\+::nom\+\_\+ville, noeud\+::parcouru, pause(), noeud\+::poids, trouve\+\_\+poids\+\_\+arc(), trouve\+\_\+voisin(), et ville\+\_\+arriver.



Référencé par main().



Voici le graphe d\textquotesingle{}appel pour cette fonction \+:
% FIG 6


\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!pause@{pause}}
\index{pause@{pause}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{pause()}]{\setlength{\rightskip}{0pt plus 5cm}void pause (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_a7167f5c196fc5e167bfabde1a730e81d}


Référencé par main(), et parcours().

\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!set\+Pixel@{set\+Pixel}}
\index{set\+Pixel@{set\+Pixel}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{set\+Pixel(int x, int y, Uint32 coul)}]{\setlength{\rightskip}{0pt plus 5cm}void set\+Pixel (
\begin{DoxyParamCaption}
\item[{int}]{x, }
\item[{int}]{y, }
\item[{Uint32}]{coul}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_ace645c902acda2805cec39d59617c675}


Références ecran.



Référencé par set\+Pixel\+Verif().

\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!set\+Pixel\+Verif@{set\+Pixel\+Verif}}
\index{set\+Pixel\+Verif@{set\+Pixel\+Verif}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{set\+Pixel\+Verif(int x, int y, Uint32 coul)}]{\setlength{\rightskip}{0pt plus 5cm}void set\+Pixel\+Verif (
\begin{DoxyParamCaption}
\item[{int}]{x, }
\item[{int}]{y, }
\item[{Uint32}]{coul}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_ad66c7ce17ba546749b02f537c43a5034}


Références set\+Pixel().



Référencé par ligne().



Voici le graphe d\textquotesingle{}appel pour cette fonction \+:
% FIG 7


\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!trouve\+\_\+poids\+\_\+arc@{trouve\+\_\+poids\+\_\+arc}}
\index{trouve\+\_\+poids\+\_\+arc@{trouve\+\_\+poids\+\_\+arc}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{trouve\+\_\+poids\+\_\+arc(char $\ast$voisin, char nom\+\_\+ville[], arc $\ast$tab\+\_\+arcs)}]{\setlength{\rightskip}{0pt plus 5cm}int trouve\+\_\+poids\+\_\+arc (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{voisin, }
\item[{char}]{nom\+\_\+ville[$\,$], }
\item[{{\bf arc} $\ast$}]{tab\+\_\+arcs}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_afee4037276ab633f259be96cdbec9c0e}
on va donner en parametre 2 noms de ville qui un arc en commun et ca va retouner le poids de l\textquotesingle{}arc 

Références nb\+\_\+arcs, et arc\+::poids.



Référencé par parcours().

\index{dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}!trouve\+\_\+voisin@{trouve\+\_\+voisin}}
\index{trouve\+\_\+voisin@{trouve\+\_\+voisin}!dijkstra\+\_\+malloc.\+c@{dijkstra\+\_\+malloc.\+c}}
\subsubsection[{trouve\+\_\+voisin(char nom\+\_\+ville[], voisin $\ast$tab\+\_\+voisins, arc $\ast$tab\+\_\+arcs)}]{\setlength{\rightskip}{0pt plus 5cm}void trouve\+\_\+voisin (
\begin{DoxyParamCaption}
\item[{char}]{nom\+\_\+ville[$\,$], }
\item[{{\bf voisin} $\ast$}]{tab\+\_\+voisins, }
\item[{{\bf arc} $\ast$}]{tab\+\_\+arcs}
\end{DoxyParamCaption}
)}\label{dijkstra__malloc_8c_a2ff7c86f3993966a1d8aceec3dfd047f}
pour une ville je vais trouver tous ses voisins 

Références nb\+\_\+arcs, arc\+::noeud1, arc\+::noeud2, et voisin\+::nom\+\_\+voisin.



Référencé par parcours().

